// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: lesson_assets.sql

package pg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addOrUpdateLessonAsset = `-- name: AddOrUpdateLessonAsset :one
INSERT INTO lesson_assets (
	page_id,
	lesson_id,
	step,
  	type,
	url
) VALUES (
  $1,$2,$3,$4,$5
)  ON CONFLICT (lesson_id,page_id,step,type) 
DO UPDATE SET url=EXCLUDED.url RETURNING asset_id,
CASE WHEN xmax = 0 THEN 'inserted' ELSE 'updated' END as operation
`

type AddOrUpdateLessonAssetParams struct {
	PageID   int32
	LessonID int32
	Step     int32
	Type     string
	Url      string
}

type AddOrUpdateLessonAssetRow struct {
	AssetID   int32
	Operation string
}

func (q *Queries) AddOrUpdateLessonAsset(ctx context.Context, arg AddOrUpdateLessonAssetParams) (AddOrUpdateLessonAssetRow, error) {
	row := q.db.QueryRow(ctx, addOrUpdateLessonAsset,
		arg.PageID,
		arg.LessonID,
		arg.Step,
		arg.Type,
		arg.Url,
	)
	var i AddOrUpdateLessonAssetRow
	err := row.Scan(&i.AssetID, &i.Operation)
	return i, err
}

const deleteLessonAsset = `-- name: DeleteLessonAsset :exec
DELETE FROM lesson_assets WHERE asset_id = $1
`

func (q *Queries) DeleteLessonAsset(ctx context.Context, assetID int32) error {
	_, err := q.db.Exec(ctx, deleteLessonAsset, assetID)
	return err
}

const getLessonAssetByCode = `-- name: GetLessonAssetByCode :many
SELECT a.lesson_id, lesson_code, title, image, asset_id, b.lesson_id, b.page_id, step, type, url, c.page_id, c.lesson_id, page FROM lesson as a 
LEFT JOIN lesson_assets as b ON a.lesson_id = b.lesson_id 
LEFT JOIN lesson_page as c ON b.page_id = c.page_id 
WHERE a.lesson_code = $1 ORDER BY c.page
`

type GetLessonAssetByCodeRow struct {
	LessonID   int32
	LessonCode string
	Title      string
	Image      string
	AssetID    pgtype.Int4
	LessonID_2 pgtype.Int4
	PageID     pgtype.Int4
	Step       pgtype.Int4
	Type       pgtype.Text
	Url        pgtype.Text
	PageID_2   pgtype.Int4
	LessonID_3 pgtype.Int4
	Page       pgtype.Int4
}

func (q *Queries) GetLessonAssetByCode(ctx context.Context, lessonCode string) ([]GetLessonAssetByCodeRow, error) {
	rows, err := q.db.Query(ctx, getLessonAssetByCode, lessonCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLessonAssetByCodeRow{}
	for rows.Next() {
		var i GetLessonAssetByCodeRow
		if err := rows.Scan(
			&i.LessonID,
			&i.LessonCode,
			&i.Title,
			&i.Image,
			&i.AssetID,
			&i.LessonID_2,
			&i.PageID,
			&i.Step,
			&i.Type,
			&i.Url,
			&i.PageID_2,
			&i.LessonID_3,
			&i.Page,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLessonAsset = `-- name: UpdateLessonAsset :exec
UPDATE lesson_assets SET url = $2 WHERE asset_id = $1
`

type UpdateLessonAssetParams struct {
	AssetID int32
	Url     string
}

func (q *Queries) UpdateLessonAsset(ctx context.Context, arg UpdateLessonAssetParams) error {
	_, err := q.db.Exec(ctx, updateLessonAsset, arg.AssetID, arg.Url)
	return err
}
