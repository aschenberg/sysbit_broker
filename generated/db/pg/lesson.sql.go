// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: lesson.sql

package pg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addOrUpdateLesson = `-- name: AddOrUpdateLesson :one
INSERT INTO lesson (lesson_code,title,image) 
VALUES($1,$2,$3) ON CONFLICT (lesson_code) 
DO UPDATE SET title=EXCLUDED.title RETURNING lesson_id, lesson_code, title, image,
CASE WHEN xmax = 0 THEN 'inserted' ELSE 'updated' END as operation
`

type AddOrUpdateLessonParams struct {
	LessonCode string
	Title      string
	Image      string
}

type AddOrUpdateLessonRow struct {
	LessonID   int32
	LessonCode string
	Title      string
	Image      string
	Operation  string
}

func (q *Queries) AddOrUpdateLesson(ctx context.Context, arg AddOrUpdateLessonParams) (AddOrUpdateLessonRow, error) {
	row := q.db.QueryRow(ctx, addOrUpdateLesson, arg.LessonCode, arg.Title, arg.Image)
	var i AddOrUpdateLessonRow
	err := row.Scan(
		&i.LessonID,
		&i.LessonCode,
		&i.Title,
		&i.Image,
		&i.Operation,
	)
	return i, err
}

const deleteLesson = `-- name: DeleteLesson :exec
DELETE FROM lesson WHERE lesson_id = $1
`

func (q *Queries) DeleteLesson(ctx context.Context, lessonID int32) error {
	_, err := q.db.Exec(ctx, deleteLesson, lessonID)
	return err
}

const getLessonDetailByCode = `-- name: GetLessonDetailByCode :many
SELECT a.lesson_id, lesson_code, title, image, content_id, b.lesson_id, b.page_id, lang, step, content, c.page_id, c.lesson_id, page FROM lesson as a 
LEFT JOIN lesson_content as b ON a.lesson_id = b.lesson_id 
LEFT JOIN lesson_page as c ON b.page_id = c.page_id 
WHERE a.lesson_code = $1 AND b.lang = ANY ($2) ORDER BY c.page
`

type GetLessonDetailByCodeParams struct {
	LessonCode string
	Lang       []string
}

type GetLessonDetailByCodeRow struct {
	LessonID   int32
	LessonCode string
	Title      string
	Image      string
	ContentID  pgtype.Int4
	LessonID_2 pgtype.Int4
	PageID     pgtype.Int4
	Lang       pgtype.Text
	Step       pgtype.Int4
	Content    pgtype.Text
	PageID_2   pgtype.Int4
	LessonID_3 pgtype.Int4
	Page       pgtype.Int4
}

func (q *Queries) GetLessonDetailByCode(ctx context.Context, arg GetLessonDetailByCodeParams) ([]GetLessonDetailByCodeRow, error) {
	rows, err := q.db.Query(ctx, getLessonDetailByCode, arg.LessonCode, arg.Lang)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLessonDetailByCodeRow{}
	for rows.Next() {
		var i GetLessonDetailByCodeRow
		if err := rows.Scan(
			&i.LessonID,
			&i.LessonCode,
			&i.Title,
			&i.Image,
			&i.ContentID,
			&i.LessonID_2,
			&i.PageID,
			&i.Lang,
			&i.Step,
			&i.Content,
			&i.PageID_2,
			&i.LessonID_3,
			&i.Page,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLessonHeader = `-- name: GetLessonHeader :many
SELECT lesson_id, lesson_code, title, image FROM lesson
ORDER BY lesson_code ASC
`

func (q *Queries) GetLessonHeader(ctx context.Context) ([]Lesson, error) {
	rows, err := q.db.Query(ctx, getLessonHeader)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lesson{}
	for rows.Next() {
		var i Lesson
		if err := rows.Scan(
			&i.LessonID,
			&i.LessonCode,
			&i.Title,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
