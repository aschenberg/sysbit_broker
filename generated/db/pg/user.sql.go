// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package pg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrUpdateUser = `-- name: CreateOrUpdateUser :one
INSERT INTO users (
  user_id,
	app_id,
	email,
  picture,
	role,
	name,
	refresh_token,
	is_deleted,
	is_active,
	created_at,
	updated_at
) VALUES (
  $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11
) ON CONFLICT (app_id) DO UPDATE SET 
picture = $12,
name = $6
RETURNING user_id, app_id, email, picture, role, is_active, name, refresh_token, is_deleted, created_at, updated_at, CASE WHEN xmax = 0 THEN 'inserted' ELSE 'updated' END as operation
`

type CreateOrUpdateUserParams struct {
	Userid       int64
	Appid        string
	Mail         string
	Pic          pgtype.Text
	Roles        []string
	Name         pgtype.Text
	Refreshtoken string
	Isdeleted    bool
	Isactive     bool
	Createdat    int64
	Updatedat    int64
	Picture      pgtype.Text
}

type CreateOrUpdateUserRow struct {
	UserID       int64
	AppID        string
	Email        string
	Picture      pgtype.Text
	Role         []string
	IsActive     bool
	Name         pgtype.Text
	RefreshToken string
	IsDeleted    bool
	CreatedAt    int64
	UpdatedAt    int64
	Operation    string
}

func (q *Queries) CreateOrUpdateUser(ctx context.Context, arg CreateOrUpdateUserParams) (CreateOrUpdateUserRow, error) {
	row := q.db.QueryRow(ctx, createOrUpdateUser,
		arg.Userid,
		arg.Appid,
		arg.Mail,
		arg.Pic,
		arg.Roles,
		arg.Name,
		arg.Refreshtoken,
		arg.Isdeleted,
		arg.Isactive,
		arg.Createdat,
		arg.Updatedat,
		arg.Picture,
	)
	var i CreateOrUpdateUserRow
	err := row.Scan(
		&i.UserID,
		&i.AppID,
		&i.Email,
		&i.Picture,
		&i.Role,
		&i.IsActive,
		&i.Name,
		&i.RefreshToken,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Operation,
	)
	return i, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT refresh_token FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetRefreshToken(ctx context.Context, userID int64) (string, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, userID)
	var refresh_token string
	err := row.Scan(&refresh_token)
	return refresh_token, err
}

const getUser = `-- name: GetUser :one
SELECT user_id, app_id, email, picture, role, is_active, name, refresh_token, is_deleted, created_at, updated_at FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, userID int64) (User, error) {
	row := q.db.QueryRow(ctx, getUser, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.AppID,
		&i.Email,
		&i.Picture,
		&i.Role,
		&i.IsActive,
		&i.Name,
		&i.RefreshToken,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserToken = `-- name: UpdateUserToken :exec
UPDATE users SET refresh_token = $2 WHERE user_id = $1
`

type UpdateUserTokenParams struct {
	UserID       int64
	RefreshToken string
}

func (q *Queries) UpdateUserToken(ctx context.Context, arg UpdateUserTokenParams) error {
	_, err := q.db.Exec(ctx, updateUserToken, arg.UserID, arg.RefreshToken)
	return err
}
