// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: lesson_content.sql

package pg

import (
	"context"
)

const addOrUpdateLessonContent = `-- name: AddOrUpdateLessonContent :one
INSERT INTO lesson_content (
	lesson_id,
	page_id,
	step,
  	lang,
	content
) VALUES (
  $1,$2,$3,$4,$5
) ON CONFLICT (lesson_id,page_id,step,lang) 
DO UPDATE SET content=EXCLUDED.content RETURNING content_id,
CASE WHEN xmax = 0 THEN 'inserted' ELSE 'updated' END as operation
`

type AddOrUpdateLessonContentParams struct {
	LessonID int32
	PageID   int32
	Step     int32
	Lang     string
	Content  string
}

type AddOrUpdateLessonContentRow struct {
	ContentID int32
	Operation string
}

func (q *Queries) AddOrUpdateLessonContent(ctx context.Context, arg AddOrUpdateLessonContentParams) (AddOrUpdateLessonContentRow, error) {
	row := q.db.QueryRow(ctx, addOrUpdateLessonContent,
		arg.LessonID,
		arg.PageID,
		arg.Step,
		arg.Lang,
		arg.Content,
	)
	var i AddOrUpdateLessonContentRow
	err := row.Scan(&i.ContentID, &i.Operation)
	return i, err
}

const deleteLessonContent = `-- name: DeleteLessonContent :exec

DELETE FROM lesson_content WHERE content_id = $1
`

// -- name: GetLesson :many
// SELECT * FROM lesson_content
// WHERE lessoncode = $1 AND lang=$2;
func (q *Queries) DeleteLessonContent(ctx context.Context, contentID int32) error {
	_, err := q.db.Exec(ctx, deleteLessonContent, contentID)
	return err
}
